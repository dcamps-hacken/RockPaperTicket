{
  "language": "Solidity",
  "sources": {
    "contracts/EventLog.sol": {
      "content": "pragma solidity 0.8.4;\n\n//This contract is a log of the created events\n\n//Error codes\nerror EventLog__NotCalledFromEventGame();\nerror EventLog__GameNotRegistering();\nerror EventLog__GameNotStarted();\n\n/** @title\n *  @author David Camps Novi\n *  @dev This contract saves all events and their details and allows to query data\n */\n// solc --userdoc --devdoc EventLog.sol\ncontract EventLog {\n    // all events ever created are stored in these structures\n    uint256 private s_numberOfEvents;\n    uint256[] s_eventIds;\n    mapping(uint256 => Event) s_events; // s_eventId => Event\n\n    // every user events are stored as userAddress => Event\n    mapping(address => uint256[]) s_registeredEvents;\n    mapping(address => uint256[]) s_createdEvents;\n\n    // the winners of each event are stored as s_eventId => userAddress => true\n    mapping(uint256 => mapping(address => bool)) s_winners;\n\n    enum GameStatus {\n        Registering,\n        Started,\n        Ended\n    }\n\n    struct Event {\n        address eventGameAddress;\n        address eventOwner;\n        string eventName;\n        uint256 numberOfTickets;\n        uint256 ticketPrice;\n        uint256 totalUsers;\n        GameStatus status;\n    }\n\n    //modifier callFromEvent() {\n    //    if (msg.sender != s_events[_eventId].eventGameAddress)\n    //        revert EventLog__NotCalledFromEventGame();\n    //    _;\n    //}\n\n    constructor() {\n        s_numberOfEvents = 0;\n    }\n\n    event GameStarted(\n        address indexed gameAddress,\n        address indexed owner,\n        uint256 timeStarted\n    );\n\n    event GameEnded(\n        address indexed gameAddress,\n        address indexed owner,\n        uint256 timeStarted\n    );\n\n    //\n    // LOG NEW EVENTS\n    //\n\n    function _logEvent(\n        uint256 _eventId,\n        address _eventGameAddress,\n        address _eventOwner,\n        string memory _eventName,\n        uint256 _numberOfTickets,\n        uint256 _ticketPrice\n    ) external {\n        s_events[_eventId] = Event(\n            _eventGameAddress,\n            _eventOwner,\n            _eventName,\n            _numberOfTickets,\n            _ticketPrice,\n            0,\n            GameStatus.Registering\n        );\n        s_numberOfEvents += 1;\n        s_eventIds.push(_eventId);\n    }\n\n    //\n    // UPDATE EVENTS\n    //\n\n    function _updateName(uint256 _eventId, string memory _newName)\n        external\n    //callFromEvent\n    {\n        if (msg.sender != s_events[_eventId].eventGameAddress)\n            revert EventLog__NotCalledFromEventGame();\n        s_events[_eventId].eventName = _newName;\n    }\n\n    function _updateTickets(uint256 _eventId, uint256 _newTickets) external {\n        if (msg.sender != s_events[_eventId].eventGameAddress)\n            revert EventLog__NotCalledFromEventGame();\n        s_events[_eventId].numberOfTickets = _newTickets;\n    }\n\n    function _updatePrice(uint256 _eventId, uint256 _newPrice) external {\n        if (msg.sender != s_events[_eventId].eventGameAddress)\n            revert EventLog__NotCalledFromEventGame();\n        s_events[_eventId].ticketPrice = _newPrice;\n    }\n\n    // LOG OTHER EVENTS\n    function _addRegisteredEvent(address _userAddress, uint256 _eventId)\n        external\n    {\n        if (msg.sender != s_events[_eventId].eventGameAddress)\n            revert EventLog__NotCalledFromEventGame();\n        s_registeredEvents[_userAddress].push(_eventId);\n        s_events[_eventId].totalUsers += 1;\n    }\n\n    function _addCreatedEvent(address _userAddress, uint256 _eventId) external {\n        //require(msg.sender == s_events[_eventId].eventGameAddress);\n        s_createdEvents[_userAddress].push(_eventId);\n    }\n\n    //\n    // CHANGE GAME STATUS\n    //\n\n    function _gameStart(uint256 _eventId) external {\n        if (msg.sender != s_events[_eventId].eventGameAddress)\n            revert EventLog__NotCalledFromEventGame();\n        if (s_events[_eventId].status != GameStatus.Registering)\n            revert EventLog__GameNotRegistering();\n        //require(s_events[_eventId].status == GameStatus.Registering);\n        s_events[_eventId].status = GameStatus.Started;\n        Event memory _event = s_events[_eventId];\n        emit GameStarted(\n            _event.eventGameAddress,\n            _event.eventOwner,\n            block.timestamp\n        );\n    }\n\n    function _gameEnd(uint256 _eventId) external {\n        if (msg.sender != s_events[_eventId].eventGameAddress)\n            revert EventLog__NotCalledFromEventGame();\n        if (s_events[_eventId].status != GameStatus.Started)\n            revert EventLog__GameNotStarted();\n        //require(s_events[_eventId].status == GameStatus.Started);\n        s_events[_eventId].status = GameStatus.Ended;\n        Event memory _event = s_events[_eventId];\n        emit GameEnded(\n            _event.eventGameAddress,\n            _event.eventOwner,\n            block.timestamp\n        );\n    }\n\n    //\n    // CHANGE GAME STATUS\n    //\n\n    function _addWinner(uint256 _eventId, address _winner) external {\n        if (msg.sender != s_events[_eventId].eventGameAddress)\n            revert EventLog__NotCalledFromEventGame();\n        s_winners[_eventId][_winner] = true;\n    }\n\n    //\n    // GETTER FUNCTIONS\n    //\n\n    function getNumberOfEvents() public view returns (uint256) {\n        return s_numberOfEvents;\n    }\n\n    function getEvent(uint256 _eventId) public view returns (Event memory) {\n        Event memory newEvent = s_events[_eventId];\n        return newEvent;\n    }\n\n    function getEventAddress(uint256 _eventId) public view returns (address) {\n        return s_events[_eventId].eventGameAddress;\n    }\n\n    function getEventOwner(uint256 _eventId) public view returns (address) {\n        return s_events[_eventId].eventOwner;\n    }\n\n    function getTicketPrice(uint256 _eventId) public view returns (uint256) {\n        return s_events[_eventId].ticketPrice;\n    }\n\n    function getTotalUsers(uint256 _eventId) public view returns (uint256) {\n        return s_events[_eventId].totalUsers;\n    }\n\n    //function getGameStatus(uint256 _eventId) public view returns (uint8) {\n    //    return s_events[_eventId].status;\n    //}\n\n    function getEventName(uint256 _eventId)\n        external\n        view\n        returns (string memory)\n    {\n        return s_events[_eventId].eventName;\n    }\n\n    function getNumberOfTickets(uint256 _eventId)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 numberOfTickets = s_events[_eventId].numberOfTickets;\n        return numberOfTickets;\n    }\n\n    function getOpenEvents() public view returns (Event[] memory) {\n        uint256 availableLength = 0;\n        for (uint256 i = 1; i <= s_numberOfEvents; i++) {\n            if (s_events[i].status == GameStatus.Registering) {\n                availableLength += 1;\n            }\n        }\n\n        Event[] memory openEvents = new Event[](availableLength);\n        uint256 currentIndex = 0;\n        for (uint256 i = 1; i <= s_numberOfEvents; i++) {\n            if (s_events[i].status == GameStatus.Registering) {\n                openEvents[currentIndex] = s_events[i];\n                currentIndex += 1;\n            }\n        }\n        return openEvents;\n    }\n\n    function getRegisteredEvents(address _userAddress)\n        public\n        view\n        returns (Event[] memory)\n    {\n        uint256[] memory registeredEvents = s_registeredEvents[_userAddress];\n        uint256 availableLength = registeredEvents.length;\n        Event[] memory registeredEventsStruct = new Event[](availableLength);\n        for (uint256 i = 0; i < availableLength; i++) {\n            uint256 eventId = registeredEvents[i];\n            Event memory newEvent = s_events[eventId];\n            registeredEventsStruct[i] = newEvent;\n        }\n        return registeredEventsStruct;\n    }\n\n    function getCreatedEvents(address _userAddress)\n        public\n        view\n        returns (Event[] memory)\n    {\n        uint256[] memory createdEvents = s_createdEvents[_userAddress];\n        uint256 availableLength = createdEvents.length;\n        Event[] memory createdEventsStruct = new Event[](availableLength);\n        for (uint256 i = 0; i < availableLength; i++) {\n            uint256 eventId = createdEvents[i];\n            Event memory newEvent = s_events[eventId];\n            createdEventsStruct[i] = newEvent;\n        }\n        return createdEventsStruct;\n    }\n\n    function _isWinner(uint256 _eventId, address _userAddress)\n        external\n        view\n        returns (bool)\n    {\n        return s_winners[_eventId][_userAddress];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}